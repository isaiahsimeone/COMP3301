Index: bin/ps/extern.h
===================================================================
RCS file: /cvs/src/bin/ps/extern.h,v
retrieving revision 1.21
diff -u -p -u -p -r1.21 extern.h
--- bin/ps/extern.h	23 Jun 2019 17:18:50 -0000	1.21
+++ bin/ps/extern.h	25 Oct 2020 15:45:20 -0000
@@ -60,6 +60,7 @@ void	 nlisterr(struct nlist *);
 void	 p_rssize(const struct kinfo_proc *, VARENT *);
 void	 pagein(const struct kinfo_proc *, VARENT *);
 void	 parsefmt(char *);
+void	 zonefmt(void);
 void	 pcpu(const struct kinfo_proc *, VARENT *);
 void	 pmem(const struct kinfo_proc *, VARENT *);
 void	 pri(const struct kinfo_proc *, VARENT *);
@@ -83,4 +84,5 @@ void	 curwd(const struct kinfo_proc *, V
 void	 euname(const struct kinfo_proc *, VARENT *);
 void	 vsize(const struct kinfo_proc *, VARENT *);
 void	 wchan(const struct kinfo_proc *, VARENT *);
+void	 zvar(const struct kinfo_proc *, VARENT *);
 __END_DECLS
Index: bin/ps/keyword.c
===================================================================
RCS file: /cvs/src/bin/ps/keyword.c,v
retrieving revision 1.47
diff -u -p -u -p -r1.47 keyword.c
--- bin/ps/keyword.c	23 Jun 2019 17:18:50 -0000	1.47
+++ bin/ps/keyword.c	25 Oct 2020 15:45:20 -0000
@@ -187,6 +187,7 @@ VAR var[] = {
 	{"vsz", "VSZ", NULL, 0, vsize, 5},
 	{"wchan", "WCHAN", NULL, LJUST, wchan, KI_WMESGLEN - 1},
 	{"xstat", "XSTAT", NULL, 0, pvar, 4, 0, POFF(p_xstat), UINT16, "x"},
+	{"zone", "ZONE", NULL, 0, zvar, 8, 0, POFF(p_zoneid)},
 	{""},
 };
 
@@ -243,6 +244,20 @@ parsefmt(char *p)
 	}
 	if (!vhead)
 		errx(1, "no valid keywords");
+}
+
+void
+zonefmt(void)
+{
+	struct varent *vent;
+
+	vent = malloc(sizeof(*vent));
+	if (vent == NULL)
+		err(1, "zone fmt malloc");
+
+	vent->var = findvar("zone");
+	vent->next = vhead;
+	vhead = vent;
 }
 
 static VAR *
Index: bin/ps/print.c
===================================================================
RCS file: /cvs/src/bin/ps/print.c,v
retrieving revision 1.75
diff -u -p -u -p -r1.75 print.c
--- bin/ps/print.c	3 Aug 2020 00:09:01 -0000	1.75
+++ bin/ps/print.c	25 Oct 2020 15:45:20 -0000
@@ -49,6 +49,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <zones.h>
 #include <limits.h>
 #include <pwd.h>
 
@@ -743,6 +744,14 @@ pvar(const struct kinfo_proc *kp, VARENT
 		(void)printf("%*s", v->width, "-");
 	else
 		printval((char *)kp + v->off, v);
+}
+
+void
+zvar(const struct kinfo_proc *kp, VARENT *ve)
+{
+	VAR *v = ve->var;
+
+	(void)printf("%*d", (int)v->width, kp->p_zoneid);
 }
 
 void
Index: bin/ps/ps.1
===================================================================
RCS file: /cvs/src/bin/ps/ps.1,v
retrieving revision 1.117
diff -u -p -u -p -r1.117 ps.1
--- bin/ps/ps.1	8 Feb 2020 16:41:25 -0000	1.117
+++ bin/ps/ps.1	25 Oct 2020 15:45:20 -0000
@@ -39,7 +39,7 @@
 .Sh SYNOPSIS
 .Nm ps
 .Sm off
-.Op Oo Fl Oc Cm AaceHhjkLlmrSTuvwx
+.Op Oo Fl Oc Cm AaceHhjkLlmrSTuvwxZ
 .Sm on
 .Op Fl M Ar core
 .Op Fl N Ar system
@@ -49,6 +49,7 @@
 .Op Fl t Ar tty
 .Op Fl U Ar username
 .Op Fl W Ar swap
+.Op Fl z Ar zone
 .Sh DESCRIPTION
 The
 .Nm
@@ -173,6 +174,10 @@ option is specified more than once,
 will use as many columns as necessary without regard for window size.
 .It Fl x
 Display information about processes without controlling terminals.
+.It Fl Z
+Prepends the displayed information with the zone field.
+.It Fl z Ar zone
+Display information about processes running in the specified zone.
 .El
 .Sh KEYWORDS
 The following is a complete list of the available keywords
Index: bin/ps/ps.c
===================================================================
RCS file: /cvs/src/bin/ps/ps.c,v
retrieving revision 1.76
diff -u -p -u -p -r1.76 ps.c
--- bin/ps/ps.c	16 Dec 2019 19:21:16 -0000	1.76
+++ bin/ps/ps.c	25 Oct 2020 15:45:20 -0000
@@ -53,6 +53,7 @@
 #include <string.h>
 #include <unistd.h>
 #include <limits.h>
+#include <zones.h>
 
 #include "ps.h"
 
@@ -70,6 +71,7 @@ int	needcomm, needenv, neednlist, comman
 enum sort { DEFAULT, SORTMEM, SORTCPU } sortby = DEFAULT;
 
 static char	*kludge_oldps_options(char *);
+static zoneid_t	 zone_lookup_name(const char *);
 static int	 pscomp(const void *, const void *);
 static void	 scanvars(void);
 static void	 usage(void);
@@ -98,6 +100,9 @@ main(int argc, char *argv[])
 	int all, ch, flag, i, fmt, lineno, nentries;
 	int prtheader, showthreads, wflag, kflag, what, Uflag, xflg;
 	char *nlistf, *memf, *swapf, *cols, errbuf[_POSIX2_LINE_MAX];
+	int Zflag = 0;
+	const char *zone = NULL;
+	zoneid_t zoneid = -1;
 
 	setlocale(LC_CTYPE, "");
 
@@ -122,7 +127,7 @@ main(int argc, char *argv[])
 	ttydev = NODEV;
 	memf = nlistf = swapf = NULL;
 	while ((ch = getopt(argc, argv,
-	    "AaCcegHhjkLlM:mN:O:o:p:rSTt:U:uvW:wx")) != -1)
+	    "AaCcegHhjkLlM:mN:O:o:p:rSTt:U:uvW:wxZz:")) != -1)
 		switch (ch) {
 		case 'A':
 			all = 1;
@@ -248,6 +253,12 @@ main(int argc, char *argv[])
 		case 'x':
 			xflg = 1;
 			break;
+		case 'Z':
+			Zflag = 1;
+			break;
+		case 'z':
+			zone = optarg;
+			break;
 		default:
 			usage();
 		}
@@ -275,6 +286,9 @@ main(int argc, char *argv[])
 	if (kd == NULL)
 		errx(1, "%s", errbuf);
 
+	if (zone != NULL)
+		zoneid = zone_lookup_name(zone);
+
 	if (unveil(_PATH_DEVDB, "r") == -1 && errno != ENOENT)
 		err(1, "unveil");
 	if (unveil(_PATH_DEV, "r") == -1 && errno != ENOENT)
@@ -297,6 +311,8 @@ main(int argc, char *argv[])
 		else
 			parsefmt(dfmt);
 	}
+	if (Zflag)
+		zonefmt();
 
 	/* XXX - should be cleaner */
 	if (!all && ttydev == NODEV && pid == -1 && !Uflag) {
@@ -361,6 +377,8 @@ main(int argc, char *argv[])
 	 * for each proc, call each variable output function.
 	 */
 	for (i = lineno = 0; i < nentries; i++) {
+		if (zoneid != -1 && zoneid != kinfo[i]->p_zoneid)
+			continue;
 		if (xflg == 0 && ((int)kinfo[i]->p_tdev == NODEV ||
 		    (kinfo[i]->p_psflags & PS_CONTROLT ) == 0))
 			continue;
@@ -381,6 +399,19 @@ main(int argc, char *argv[])
 	exit(eval);
 }
 
+static zoneid_t
+zone_lookup_name(const char *zone)
+{
+	const char *errstr;
+	zoneid_t z;
+
+	z = strtonum(zone, 0, MAXZONEIDS, &errstr);
+	if (errstr != NULL)
+		errx(1, "zone %s: %s", zone, errstr);
+
+	return (z);
+}
+
 static void
 scanvars(void)
 {
@@ -486,9 +517,9 @@ static void
 usage(void)
 {
 	(void)fprintf(stderr,
-	    "usage: %s [-AaceHhjkLlmrSTuvwx] [-M core] [-N system] [-O fmt] [-o fmt] [-p pid]\n",
+	    "usage: %s [-AaceHhjkLlmrSTuvwxZ] [-M core] [-N system] [-O fmt] [-o fmt] [-p pid]\n",
 	    __progname);
 	(void)fprintf(stderr,
-	    "%-*s[-t tty] [-U username] [-W swap]\n", (int)strlen(__progname) + 8, "");
+	    "%-*s[-t tty] [-U username] [-W swap] [-z zone]\n", (int)strlen(__progname) + 8, "");
 	exit(1);
 }
Index: include/Makefile
===================================================================
RCS file: /cvs/src/include/Makefile,v
retrieving revision 1.226
diff -u -p -u -p -r1.226 Makefile
--- include/Makefile	14 Nov 2019 21:14:53 -0000	1.226
+++ include/Makefile	25 Oct 2020 15:47:07 -0000
@@ -29,7 +29,8 @@ FILES=	a.out.h ar.h asr.h assert.h \
 	tar.h tgmath.h tib.h time.h ttyent.h \
 	unistd.h utime.h utmp.h uuid.h \
 	vis.h  \
-	wchar.h wctype.h
+	wchar.h wctype.h \
+	zones.h
 
 MFILES=	frame.h
 LFILES=	endian.h fcntl.h syslog.h termios.h stdarg.h stdint.h varargs.h
Index: include/zones.h
===================================================================
RCS file: include/zones.h
diff -N include/zones.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ include/zones.h	25 Oct 2020 15:47:07 -0000
@@ -0,0 +1,32 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2019 The University of Queensland
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _ZONES_H_
+#define	_ZONES_H_
+
+#include <sys/zones.h>
+
+__BEGIN_DECLS
+int		zone_create(zoneid_t);
+int		zone_destroy(zoneid_t);
+int		zone_enter(zoneid_t);
+int		zone_list(zoneid_t *, size_t *);
+zoneid_t	zone_lookup(zoneid_t);
+__END_DECLS
+
+#endif /* !_UNISTD_H_ */
Index: lib/libc/Symbols.list
===================================================================
RCS file: /cvs/src/lib/libc/Symbols.list,v
retrieving revision 1.73
diff -u -p -u -p -r1.73 Symbols.list
--- lib/libc/Symbols.list	24 Oct 2019 05:57:41 -0000	1.73
+++ lib/libc/Symbols.list	25 Oct 2020 15:47:08 -0000
@@ -1765,3 +1765,10 @@ yperr_string
 ypprot_err
 _yp_check		/* chpass, passwd, login_chpass */
 yp_unbind		/* passwd */
+
+/* zones */
+zone_create
+zone_destroy
+zone_enter
+zone_list
+zone_lookup
Index: lib/libc/shlib_version
===================================================================
RCS file: /cvs/src/lib/libc/shlib_version,v
retrieving revision 1.209
diff -u -p -u -p -r1.209 shlib_version
--- lib/libc/shlib_version	23 Oct 2019 19:33:41 -0000	1.209
+++ lib/libc/shlib_version	25 Oct 2020 15:47:08 -0000
@@ -1,4 +1,4 @@
 major=96
-minor=0
+minor=1
 # note: If changes were made to include/thread_private.h or if system calls
 # were added/changed then librthread/shlib_version must also be updated.
Index: lib/libc/sys/Makefile.inc
===================================================================
RCS file: /cvs/src/lib/libc/sys/Makefile.inc,v
retrieving revision 1.159
diff -u -p -u -p -r1.159 Makefile.inc
--- lib/libc/sys/Makefile.inc	6 Jul 2020 13:33:06 -0000	1.159
+++ lib/libc/sys/Makefile.inc	25 Oct 2020 15:47:09 -0000
@@ -74,7 +74,9 @@ ASM=	__semctl.o __syscall.o __thrsigdive
 	shmget.o shutdown.o sigaltstack.o socket.o \
 	socketpair.o stat.o statfs.o swapctl.o symlink.o symlinkat.o \
 	sysarch.o sysctl.o thrkill.o unlink.o unlinkat.o \
-	unmount.o unveil.o utimensat.o utimes.o utrace.o
+	unmount.o unveil.o utimensat.o utimes.o utrace.o \
+	zone_create.o zone_destroy.o zone_enter.o zone_list.o \
+	zone_lookup.o
 
 SRCS+=	${SRCS_${MACHINE_CPU}}
 .for i in ${SRCS_${MACHINE_CPU}}
Index: sys/conf/files
===================================================================
RCS file: /cvs/src/sys/conf/files,v
retrieving revision 1.691
diff -u -p -u -p -r1.691 files
--- sys/conf/files	20 Jul 2020 00:15:59 -0000	1.691
+++ sys/conf/files	25 Oct 2020 15:47:15 -0000
@@ -693,6 +693,7 @@ file kern/kern_rwlock.c
 file kern/kern_physio.c
 file kern/kern_proc.c
 file kern/kern_prot.c
+file kern/kern_zone.c
 file kern/kern_resource.c
 file kern/kern_pledge.c
 file kern/kern_unveil.c
Index: sys/kern/init_sysent.c
===================================================================
RCS file: /cvs/src/sys/kern/init_sysent.c,v
retrieving revision 1.218
diff -u -p -u -p -r1.218 init_sysent.c
--- sys/kern/init_sysent.c	18 Mar 2020 19:35:00 -0000	1.218
+++ sys/kern/init_sysent.c	25 Oct 2020 15:47:18 -0000
@@ -1,4 +1,4 @@
-/*	$OpenBSD: init_sysent.c,v 1.218 2020/03/18 19:35:00 anton Exp $	*/
+/*	$OpenBSD$	*/
 
 /*
  * System call switch table.
@@ -457,16 +457,16 @@ struct sysent sysent[] = {
 	    sys_nosys },			/* 208 = obsolete nnpfspioctl */
 	{ 3, s(struct sys_utrace_args), 0,
 	    sys_utrace },			/* 209 = utrace */
-	{ 0, 0, 0,
-	    sys_nosys },			/* 210 = unimplemented */
-	{ 0, 0, 0,
-	    sys_nosys },			/* 211 = unimplemented */
-	{ 0, 0, 0,
-	    sys_nosys },			/* 212 = unimplemented */
-	{ 0, 0, 0,
-	    sys_nosys },			/* 213 = unimplemented */
-	{ 0, 0, 0,
-	    sys_nosys },			/* 214 = unimplemented */
+	{ 1, s(struct sys_zone_create_args), 0,
+	    sys_zone_create },			/* 210 = zone_create */
+	{ 1, s(struct sys_zone_destroy_args), 0,
+	    sys_zone_destroy },			/* 211 = zone_destroy */
+	{ 1, s(struct sys_zone_enter_args), 0,
+	    sys_zone_enter },			/* 212 = zone_enter */
+	{ 2, s(struct sys_zone_list_args), 0,
+	    sys_zone_list },			/* 213 = zone_list */
+	{ 1, s(struct sys_zone_lookup_args), 0,
+	    sys_zone_lookup },			/* 214 = zone_lookup */
 	{ 0, 0, 0,
 	    sys_nosys },			/* 215 = unimplemented */
 	{ 0, 0, 0,
Index: sys/kern/kern_fork.c
===================================================================
RCS file: /cvs/src/sys/kern/kern_fork.c,v
retrieving revision 1.226
diff -u -p -u -p -r1.226 kern_fork.c
--- sys/kern/kern_fork.c	25 Oct 2020 01:55:18 -0000	1.226
+++ sys/kern/kern_fork.c	25 Oct 2020 15:47:18 -0000
@@ -182,6 +182,7 @@ process_initialize(struct process *pr, s
 	TAILQ_INIT(&pr->ps_threads);
 	TAILQ_INSERT_TAIL(&pr->ps_threads, p, p_thr_link);
 	pr->ps_refcnt = 1;
+	pr->ps_zid = 0;
 	p->p_p = pr;
 
 	/* give the process the same creds as the initial thread */
@@ -226,6 +227,7 @@ process_new(struct proc *p, struct proce
 
 	process_initialize(pr, p);
 	pr->ps_pid = allocpid();
+	pr->ps_zid = parent->ps_zid; /* Child shares parents zone */
 	lim_fork(parent, pr);
 
 	/* post-copy fixups */
Index: sys/kern/kern_pledge.c
===================================================================
RCS file: /cvs/src/sys/kern/kern_pledge.c,v
retrieving revision 1.266
diff -u -p -u -p -r1.266 kern_pledge.c
--- sys/kern/kern_pledge.c	16 Sep 2020 13:50:42 -0000	1.266
+++ sys/kern/kern_pledge.c	25 Oct 2020 15:47:18 -0000
@@ -365,6 +365,8 @@ const uint64_t pledge_syscalls[SYS_MAXSY
 	[SYS_flock] = PLEDGE_FLOCK | PLEDGE_YPACTIVE,
 
 	[SYS_swapctl] = PLEDGE_VMINFO,	/* XXX should limit to "get" operations */
+
+	/* [SYS_zone_lookup] = PLEDGE_ALWAYS, */
 };
 
 static const struct {
Index: sys/kern/kern_sig.c
===================================================================
RCS file: /cvs/src/sys/kern/kern_sig.c,v
retrieving revision 1.263
diff -u -p -u -p -r1.263 kern_sig.c
--- sys/kern/kern_sig.c	16 Sep 2020 13:50:42 -0000	1.263
+++ sys/kern/kern_sig.c	25 Oct 2020 15:47:18 -0000
@@ -147,8 +147,13 @@ cansignal(struct proc *p, struct process
 	struct ucred *uc = p->p_ucred;
 	struct ucred *quc = qr->ps_ucred;
 
-	if (uc->cr_uid == 0)
-		return (1);		/* root can always signal */
+	/* root user in global zone can always signal */
+	if (uc->cr_uid == 0 && pr->ps_zid == 0)
+		return (1);
+
+	/* Non-root user in global zone can't signal process in another zone */
+	if (uc->cr_uid != 0 && pr->ps_zid == 0 && pr->ps_zid != qr->ps_zid)
+		return (0);
 
 	if (pr == qr)
 		return (1);		/* process can always signal itself */
@@ -591,6 +596,7 @@ sys_kill(struct proc *cp, void *v, regis
 		syscallarg(int) signum;
 	} */ *uap = v;
 	struct process *pr;
+	struct process *cpr = cp->p_p;
 	int pid = SCARG(uap, pid);
 	int signum = SCARG(uap, signum);
 	int error;
@@ -607,6 +613,13 @@ sys_kill(struct proc *cp, void *v, regis
 			else
 				zombie = 1;
 		}
+		/* 
+		 * Non-global zone process can't signal any  
+		 * process in a different zone
+		 */
+		if (cpr->ps_zid != 0 && cpr->ps_zid != pr->ps_zid)
+			return (ESRCH);
+
 		if (!cansignal(cp, pr, signum))
 			return (EPERM);
 
Index: sys/kern/kern_sysctl.c
===================================================================
RCS file: /cvs/src/sys/kern/kern_sysctl.c,v
retrieving revision 1.380
diff -u -p -u -p -r1.380 kern_sysctl.c
--- sys/kern/kern_sysctl.c	19 Oct 2020 08:19:46 -0000	1.380
+++ sys/kern/kern_sysctl.c	25 Oct 2020 15:47:18 -0000
@@ -1,4 +1,4 @@
-/*	$OpenBSD: kern_sysctl.c,v 1.380 2020/10/19 08:19:46 mpi Exp $	*/
+/*	$OpenBSD: kern_sysctl.c,v 1.379 2020/09/01 01:53:50 gnezdo Exp $	*/
 /*	$NetBSD: kern_sysctl.c,v 1.17 1996/05/20 17:49:05 mrg Exp $	*/
 
 /*-
@@ -81,6 +81,7 @@
 #include <sys/syscallargs.h>
 #include <sys/wait.h>
 #include <sys/witness.h>
+#include <sys/zones.h>
 
 #include <uvm/uvm_extern.h>
 
@@ -149,6 +150,11 @@ void fill_file(struct kinfo_file *, stru
 void fill_kproc(struct process *, struct kinfo_proc *, struct proc *, int);
 
 int (*cpu_cpuspeed)(int *);
+/* Functions pertaining to zoning */
+int	zone_recorded(zoneid_t);
+int	zone_cmp(struct zone_node *, struct zone_node *);
+void	zone_populate_init_zn(struct zone_node *, zoneid_t);
+struct	zone_node *zone_get_zn(zoneid_t);
 
 /*
  * Lock to avoid too many processes vslocking a large amount of memory
@@ -157,6 +163,13 @@ int (*cpu_cpuspeed)(int *);
 struct rwlock sysctl_lock = RWLOCK_INITIALIZER("sysctllk");
 struct rwlock sysctl_disklock = RWLOCK_INITIALIZER("sysctldlk");
 
+/*
+ * Splay tree used for tracking zone variables (e.g. hostname, domainname etc)
+ */
+SPLAY_HEAD(zone_tree, zone_node) zone_head = SPLAY_INITIALIZER(&zone_head);
+SPLAY_PROTOTYPE(zone_tree, zone_node, entry, zone_cmp);
+SPLAY_GENERATE(zone_tree, zone_node, entry, zone_cmp);
+
 int
 sys_sysctl(struct proc *p, void *v, register_t *retval)
 {
@@ -168,6 +181,7 @@ sys_sysctl(struct proc *p, void *v, regi
 		syscallarg(void *) new;
 		syscallarg(size_t) newlen;
 	} */ *uap = v;
+	struct zone_node *zn;
 	int error, dolock = 1;
 	size_t savelen = 0, oldlen = 0;
 	sysctlfn *fn;
@@ -190,6 +204,15 @@ sys_sysctl(struct proc *p, void *v, regi
 	    name, SCARG(uap, new));
 	if (error)
 		return (error);
+	/*
+	 * If a new zone is encountered, create a new tree node to record
+	 * the CTL variables associated with the zone
+	 */
+	if (!zone_recorded(p->p_p->ps_zid)) {
+		zn = malloc(sizeof(struct zone_node), M_TEMP, M_WAITOK);
+		zone_populate_init_zn(zn, p->p_p->ps_zid);
+		SPLAY_INSERT(zone_tree, &zone_head, zn);
+	}
 
 	switch (name[0]) {
 	case CTL_KERN:
@@ -262,6 +285,106 @@ sys_sysctl(struct proc *p, void *v, regi
 }
 
 /*
+ * Compares zone nodes by zone id for operations on a splay tree of
+ * zone nodes.
+ *
+ *	zn1:   The first zone node to compare
+ *	zn2:   The second zone node to compare
+ *
+ *  returns:   
+ */
+int
+zone_cmp(struct zone_node *zn1, struct zone_node *zn2)
+{
+	return (zn1->zid < zn2->zid ? -1 : zn1->zid > zn2->zid);
+}
+
+/*
+ * Populates the fields of a zone_node struct with default variable
+ * values (e.g. hostname, domainname, etc)
+ *
+ * Memory should be allocated for zone_node prior to using this function
+ *
+ *	 zn:   A pointer to the zone_node struct to populate.
+ *	zid:   The zone id which the zone_node should represent.
+ */
+void
+zone_populate_init_zn(struct zone_node *zn, zoneid_t zid)
+{	
+	struct zone_variables *vars = malloc(sizeof(struct zone_variables),
+	    M_TEMP, M_WAITOK);
+
+	if (zid == 0)
+		/* Global zone hostname empty by default */
+		vars->hostname[0] = '\0';
+	else
+		/* Non-global zone hostname Defaults to id of zone */
+		snprintf(vars->hostname, sizeof(zoneid_t), "%d", zid);
+
+	/* Get length of hostname */
+	vars->hostnamelen = strlen(vars->hostname);
+	/* Domain name empty by default for all zones */
+	vars->domainname[0] = '\0';
+	vars->domainnamelen = 0;
+	/* Host id 0 by default for all zones */
+	vars->hostid = 0;
+	/* Assign to passed in structure */
+	zn->zid = zid;
+	zn->vars = vars;
+}
+
+/*
+ * Gets the pointer to the zone_node which is associated with the specified
+ * zone identifier (zid.)
+ *
+ *	zid:   The zone id of the zone_node struct to be returned
+ *
+ *  returns:   A pointer to the zone_node struct for the relevant zone id
+ *	       or NULL if that zone id has no zone_node associated.
+ */
+struct zone_node *
+zone_get_zn(zoneid_t zid) {
+	struct zone_node target;
+	target.zid = zid;
+	return SPLAY_FIND(zone_tree, &zone_head, &target);
+}
+
+/*
+ * Determines whether a zone node (by its zone id) is recorded
+ * within the splay tree of zones (zone_tree).
+ *
+ *	zid:   The id of the zone that will be checked
+ *
+ *  returns:   1 if the zone is in the zone_tree splay, 0 otherwise
+ */
+int
+zone_recorded(zoneid_t zid) 
+{
+	return (zone_get_zn(zid) != NULL);
+}
+
+/*
+ * Removes the variables associated with a zone via the specified
+ * zone id. Removal is actioned by removing the specified zone
+ * entry from the splay tree of zones.
+ *
+ *	zid:   The id of the zone to be removed from the tree of zones.
+ */
+void
+sysctl_destroy_zone(zoneid_t zid)
+{
+	struct zone_node *target, *res;
+
+	if ((target = zone_get_zn(zid)) == NULL)
+		/* No sysctl variables stored */
+		return ;
+	if ((res = SPLAY_REMOVE(zone_tree, &zone_head, target)) == NULL)
+		/* Should never reach - To be safe */
+		return ;
+	free(res->vars, M_TEMP, 0);
+}
+
+/*
  * Attributes stored in the kernel.
  */
 char hostname[MAXHOSTNAMELEN];
@@ -290,6 +413,11 @@ kern_sysctl(int *name, u_int namelen, vo
 	extern int pool_debug;
 	extern int uvm_wxabort;
 
+	/* Get the zone node of the calling process (by zone id) */
+	struct zone_node *zn = zone_get_zn(p->p_p->ps_zid);
+	if (zn == NULL)
+		return (ESRCH); /* Should never be reached */
+
 	/* all sysctl names at this level are terminal except a ton of them */
 	if (namelen != 1) {
 		switch (name[0]) {
@@ -367,32 +495,39 @@ kern_sysctl(int *name, u_int namelen, vo
 		return (sysctl_int(oldp, oldlenp, newp, newlen, &allowkmem));
 	case KERN_HOSTNAME:
 		error = sysctl_tstring(oldp, oldlenp, newp, newlen,
-		    hostname, sizeof(hostname));
+		    zn->vars->hostname, sizeof(zn->vars->hostname));
 		if (newp && !error)
-			hostnamelen = newlen;
+			zn->vars->hostnamelen = newlen;
 		return (error);
 	case KERN_DOMAINNAME:
 		error = sysctl_tstring(oldp, oldlenp, newp, newlen,
-		    domainname, sizeof(domainname));
+		    zn->vars->domainname, sizeof(zn->vars->domainname));
 		if (newp && !error)
-			domainnamelen = newlen;
+			zn->vars->domainnamelen = newlen;
 		return (error);
 	case KERN_HOSTID:
-		inthostid = hostid;  /* XXX assumes sizeof long <= sizeof int */
+		inthostid = zn->vars->hostid;  /* XXX assumes sizeof long <= sizeof int */
 		error =  sysctl_int(oldp, oldlenp, newp, newlen, &inthostid);
-		hostid = inthostid;
+		zn->vars->hostid = inthostid;
 		return (error);
 	case KERN_CLOCKRATE:
 		return (sysctl_clockrate(oldp, oldlenp, newp));
 	case KERN_BOOTTIME: {
 		struct timeval bt;
-		memset(&bt, 0, sizeof bt);
-		microboottime(&bt);
-		return (sysctl_rdstruct(oldp, oldlenp, newp, &bt, sizeof bt));
+		/* 
+		 * Global zone is created at boot time. Otherwise,
+		 * get the zone creation time (kern_zone.c)
+		 */
+		if (zn->zid == 0)
+			microboottime(&bt);
+		else
+			bt = *zones_get_creation_time(zn->zid);
+
+		return (sysctl_rdstruct(oldp, oldlenp, newp, &bt, sizeof(bt)));
 	  }
 #ifndef SMALL_KERNEL
 	case KERN_PROC:
-		return (sysctl_doproc(name + 1, namelen - 1, oldp, oldlenp));
+		return (sysctl_doproc(p, name + 1, namelen - 1, oldp, oldlenp));
 	case KERN_PROC_ARGS:
 		return (sysctl_proc_args(name + 1, namelen - 1, oldp, oldlenp,
 		     p));
@@ -596,9 +731,16 @@ kern_sysctl(int *name, u_int namelen, vo
 #endif
 	case KERN_MAXCLUSTERS: {
 		int val = nmbclust;
-		error = sysctl_int(oldp, oldlenp, newp, newlen, &val);
-		if (error == 0 && val != nmbclust)
-			error = nmbclust_update(val);
+
+		if (zn->zid == 0) {
+			/* Global zone */
+			error = sysctl_int(oldp, oldlenp, newp, newlen, &val);
+			if (error == 0 && val != nmbclust)
+				error = nmbclust_update(val);
+		} else {
+			/* Non-Global zone */
+			error = sysctl_rdint(oldp, oldlenp, newp, val);
+		}
 		return (error);
 	}
 #ifndef SMALL_KERNEL
@@ -618,10 +760,17 @@ kern_sysctl(int *name, u_int namelen, vo
 		u_int64_t dmapages;
 		int opct, pgs;
 		opct = bufcachepercent;
-		error = sysctl_int(oldp, oldlenp, newp, newlen,
-		    &bufcachepercent);
+		if (zn->zid == 0)
+			/* Global Zone */
+			error = sysctl_int(oldp, oldlenp, newp, newlen,
+		    	    &bufcachepercent);
+		else
+			/* Non-Global Zone */
+			error = sysctl_rdint(oldp, oldlenp, newp,
+			    bufcachepercent);
 		if (error)
 			return(error);
+
 		if (bufcachepercent > 90 || bufcachepercent < 5) {
 			bufcachepercent = opct;
 			return (EINVAL);
@@ -647,10 +796,16 @@ kern_sysctl(int *name, u_int namelen, vo
 	case KERN_POOL_DEBUG: {
 		int old_pool_debug = pool_debug;
 
-		error = sysctl_int(oldp, oldlenp, newp, newlen,
-		    &pool_debug);
-		if (error == 0 && pool_debug != old_pool_debug)
-			pool_reclaim_all();
+		if (zn->zid == 0) {
+			/* Global zone */
+			error = sysctl_int(oldp, oldlenp, newp, newlen,
+			    &pool_debug);
+			if (error == 0 && pool_debug != old_pool_debug)
+				pool_reclaim_all();
+		} else {
+			/* Non-Global zone */
+			error = sysctl_rdint(oldp, oldlenp, newp, pool_debug);
+		}
 		return (error);
 	}
 #ifdef PTRACE
@@ -1337,6 +1492,7 @@ sysctl_file(int *name, u_int namelen, ch
 	struct filedesc *fdp;
 	struct file *fp;
 	struct process *pr;
+	struct process *cpr = p->p_p;
 	size_t buflen, elem_size, elem_count, outsize;
 	char *dp = where;
 	int arg, i, error = 0, needed = 0, matched;
@@ -1432,6 +1588,13 @@ sysctl_file(int *name, u_int namelen, ch
 				/* not the pid we are looking for */
 				continue;
 			}
+			/*
+			 * If the calling process isn't in the global zone,
+			 * skip processes in different zones.
+			 */
+			if (cpr->ps_zid != 0 && cpr->ps_zid != pr->ps_zid)
+				continue;
+			
 			matched = 1;
 			fdp = pr->ps_fd;
 			if (pr->ps_textvp)
@@ -1464,6 +1627,13 @@ sysctl_file(int *name, u_int namelen, ch
 				/* not the uid we are looking for */
 				continue;
 			}
+			/*
+			 * If the calling process isn't in the global zone,
+			 * skip processes in different zones.
+			 */
+			if (cpr->ps_zid != 0 && cpr->ps_zid != pr->ps_zid)
+				continue;
+
 			fdp = pr->ps_fd;
 			if (fdp->fd_cdir)
 				FILLIT(NULL, NULL, KERN_FILE_CDIR, fdp->fd_cdir, pr);
@@ -1502,11 +1672,13 @@ sysctl_file(int *name, u_int namelen, ch
 #define KERN_PROCSLOP	5
 
 int
-sysctl_doproc(int *name, u_int namelen, char *where, size_t *sizep)
+sysctl_doproc(struct proc *cp, int *name, u_int namelen,
+    char *where, size_t *sizep)
 {
 	struct kinfo_proc *kproc = NULL;
 	struct proc *p;
 	struct process *pr;
+	struct process *cpr = cp->p_p;
 	char *dp;
 	int arg, buflen, doingzomb, elem_size, elem_count;
 	int error, needed, op;
@@ -1548,6 +1720,13 @@ again:
 			continue;
 
 		/*
+		 * If the calling process isn't in the global zone,
+		 * skip processes in different zones.
+		 */
+		if (cpr->ps_zid != 0 && cpr->ps_zid != pr->ps_zid)
+			continue;
+		
+		/*
 		 * TODO - make more efficient (see notes below).
 		 */
 		switch (op) {
@@ -1671,6 +1850,8 @@ fill_kproc(struct process *pr, struct ki
 	    p, pr, s, vm, pr->ps_limit, pr->ps_sigacts, isthread,
 	    show_pointers);
 
+	/* Set zone identifier from process */
+	ki->p_zoneid = pr->ps_zid;
 	/* stuff that's too painful to generalize into the macros */
 	if (pr->ps_pptr)
 		ki->p_ppid = pr->ps_pptr->ps_pid;
@@ -1792,7 +1973,7 @@ sysctl_proc_args(int *name, u_int namele
 
 	ps_strings = vpr->ps_strings;
 	vm = vpr->ps_vmspace;
-	uvmspace_addref(vm);
+	vm->vm_refcnt++;
 	vpr = NULL;
 
 	buf = malloc(PAGE_SIZE, M_TEMP, M_WAITOK);
Index: sys/kern/kern_zone.c
===================================================================
RCS file: sys/kern/kern_zone.c
diff -N sys/kern/kern_zone.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sys/kern/kern_zone.c	25 Oct 2020 15:47:18 -0000
@@ -0,0 +1,398 @@
+#include <sys/zones.h>
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/ucred.h>		/* For determining access level */
+#include <sys/proc.h>		/* For struct proc/process */
+#include <sys/malloc.h>
+#include <sys/atomic.h>		/* For atomic inc/dec operations */
+#include <sys/time.h>		/* For timing zone creations */
+#include <sys/mount.h>
+#include <sys/syscallargs.h>
+#include <sys/sysctl.h>
+
+struct zone {
+	TAILQ_ENTRY(zone) entry;
+	zoneid_t	zid;
+	struct		timeval *creation_time;
+};
+TAILQ_HEAD(, zone) zones = TAILQ_HEAD_INITIALIZER(zones);
+
+int	zone_exists(zoneid_t);
+int	is_authorised(struct proc *);
+int	zone_in_use(zoneid_t);
+void	populate_zone_fields(struct zone *, zoneid_t);
+void	free_zone(struct zone *);
+
+/* Read/write lock for modifying queue of zone structs */
+struct rwlock zone_queue_lock = RWLOCK_INITIALIZER("zones");
+/* Tracks the number of zones that exist */
+int zone_count = 0;
+
+/*
+ * Creates a new zone on the system with a zone identifier designated by
+ * the caller. This zone shall exist for the remainder of the system uptime
+ * or until the zone is explicity destroyed via syscall.
+ *
+ *	  p:   The process which initated the syscall.
+ *	  v:   The parameters passed by the process that initiated the syscall.
+ *   retval:   The value returned to the process that initiated the syscall.
+ *
+ *  returns:   EPERM If the process which initiated the syscall is not root or
+ *	       not in the global zone.
+ *	       ERANGE If too many zones are running on the system.
+ *	       EBUSY If a zone already exists with the requested zone id.
+ */
+int
+sys_zone_create(struct proc *p, void *v, register_t *retval)
+{
+	struct sys_zone_create_args /* {
+		syscallarg(zoneid_t) z;
+	} */ *uap = v;
+	struct zone *zone;
+	zoneid_t requested_zid = SCARG(uap, z);
+	*retval = -1;
+
+	/* Must be root and in global zone */
+	if (!is_authorised(p))
+		return (EPERM);
+	/* Check that a new zone wouldn't exceed MAXZONES */
+	if (zone_count == MAXZONES)
+		return (ERANGE);
+	/* Check if a zone with this zone id already exists */
+	if (zone_exists(requested_zid) != -1)
+		return (EBUSY);
+
+	/* Create, populate and insert new zone */
+	zone = malloc(sizeof(struct zone), M_TEMP, M_WAITOK);
+	populate_zone_fields(zone, requested_zid);
+
+	/* Safely queue the zone */
+	rw_enter_write(&zone_queue_lock);
+	TAILQ_INSERT_TAIL(&zones, zone, entry);
+	rw_exit_write(&zone_queue_lock);
+	/* Increment zone counter */
+	atomic_inc_int(&zone_count);
+
+	*retval = 0;
+	return (0);
+}
+
+/*
+ * Destroys a zone specified by a zone identifier.
+ *
+ *	  p:   The process which initated the syscall.
+ *	  v:   The parameters passed by the process that initiated the syscall.
+ *   retval:   The value returned to the process that initiated the syscall.
+ *
+ *  returns:   EPERM If the process which initiated the syscall is not root or
+ *	       not in the global zone.
+ *	       ESRCH If the specified zone does not exist
+ *	       EBUSY If the zone with the specified zone id is currently
+ *	       occupied by a process.
+ */
+int
+sys_zone_destroy(struct proc *p, void *v, register_t *retval)
+{
+	struct zone *z, *tz;
+	struct sys_zone_destroy_args /* {
+		syscallarg(zoneid_t) z;
+	} */ *uap = v;
+	zoneid_t target_zid = SCARG(uap, z);
+	*retval = -1;
+
+	/* Is the caller root and in global zone */
+	if (!is_authorised(p))
+		return EPERM;
+	/* Does the specified zone exist */
+	if (zone_exists(target_zid) == -1)
+		return ESRCH;
+	/* Is there still a process running? */
+	if (zone_in_use(target_zid))
+		return EBUSY;
+
+	/* Destroy the zone */
+	TAILQ_FOREACH_SAFE(z, &zones, entry, tz)
+		if (z->zid == target_zid) {
+			/* Safely remove the zone from the queue */
+			rw_enter_write(&zone_queue_lock);
+			TAILQ_REMOVE(&zones, z, entry);
+			rw_exit_write(&zone_queue_lock);
+			/* Zone no longer needed */
+			free_zone(z);
+			/* Decrement zone counter */
+			atomic_dec_int(&zone_count);
+			/* Tell sysctl to forget any zone variables */
+			sysctl_destroy_zone(target_zid);
+		}
+
+	*retval = 0;
+	return (0);
+}
+
+/*
+ * Moves the process which initiated the syscall into the zone specified.
+ *
+ *	  p:   The process which initiated the syscall.
+ *	  v:   The parameters passed by the process that initiated the syscall.
+ *   retval:   The value returned to the process that initiated the syscall.
+ *
+ *  returns:   EPERM If the process which initiated the syscall is not root or
+ *	       not in the global zone.
+ *	       ESRCH If the specified zone does not exist
+ */
+int
+sys_zone_enter(struct proc *p, void *v, register_t *retval)
+{
+	struct sys_zone_enter_args /* {
+		syscallarg(zoneid_t) z;
+	} */ *uap = v;
+	zoneid_t target_zid = SCARG(uap, z);
+	*retval = -1;
+
+	/* Is the caller root and in global zone */
+	if (!is_authorised(p))
+		return EPERM;
+	/* Does the specified zone exist */
+	if (zone_exists(target_zid) == -1)
+		return ESRCH;
+
+	/* Change the calling processes zone identifier */
+	p->p_p->ps_zid = target_zid;
+
+	*retval = 0;
+	return (0);
+}
+
+/*
+ * Copies out to the calling process the list of zones that currently exist
+ * on the system, as well as the number of zones existing.
+ *
+ *	  p:   The process which initiated the syscall.
+ *	  v:   The parameters passed by the process that initiated the syscall.
+ *   retval:   The value returned to the process that initiated the syscall.
+ *
+ *  returns:   EFAULT if either of the arguments supplied by the caller
+ *	       specify a bad address.
+ *	       ERANGE if the number pointer to by the syscall argument, nzs,
+ *	       is less than the number of zones presently running on the system
+ */
+int
+sys_zone_list(struct proc *p, void *v, register_t *retval)
+{
+	struct sys_zone_list_args /* {
+		syscallarg(zoneid_t *) zs;
+		syscallarg(size_t *) nzs;
+	} */ *uap = v;
+	zoneid_t *zs = SCARG(uap, zs);
+	size_t *nzs = SCARG(uap, nzs);
+	struct zone *z;
+	int err, err2, num_zones = 1;
+	*retval = -1;
+
+	/* Check there is enough space to copy out zone list */
+	if (*nzs < zone_count)
+		return (ERANGE);
+
+	if (p->p_p->ps_zid != 0) {
+		/* Non-Global zone caller */
+		err = copyout(&p->p_p->ps_zid, zs, sizeof(zoneid_t));
+
+	} else {
+		/* Global zone caller */
+		/* Allocate space for list of zones */
+		zoneid_t *zlist = malloc(*nzs * sizeof(zoneid_t), M_TEMP,
+		    M_WAITOK|M_ZERO);
+
+		/* Global zone (0) should appear in the returned list */
+		zlist[0] = 0;
+
+		/* Safely copy zones from queue */
+		rw_enter_read(&zone_queue_lock);
+		TAILQ_FOREACH(z, &zones, entry)
+			zlist[num_zones++] = z->zid;
+		rw_exit_read(&zone_queue_lock);
+
+		/* Copy zone list to userspace */
+		err = copyout(zlist, zs, *nzs * sizeof(zs));
+
+		free(zlist, M_TEMP, 0);
+	}
+
+	/* Copy zone count to userspace */
+	err2 = copyout(&num_zones, nzs, sizeof(num_zones));
+
+	/* Bad address encountered while copying out */
+	if (err != 0 || err2 != 0)
+		return (EFAULT);
+	
+	*retval = 0;
+	return (0);
+}
+
+/*
+ * Checks whether a zone with a specified zone identifier exists.
+ *
+ *	  p:   The process which initiated the syscall.
+ *	  v:   The parameters passed by the process that initiated the syscall.
+ *   retval:   The value returned to the process that initiated the syscall.
+ *
+ *  returns:   ESRCH if the process which initiated the syscall is not in the
+ *	       global zone, or if the zone specified (by id) does not exist
+ */
+int
+sys_zone_lookup(struct proc *p, void *v, register_t *retval)
+{
+	struct sys_zone_lookup_args /* {
+		syscallarg(zoneid_t) z;
+	} */ *uap = v;
+	struct process *pr = p->p_p;
+	zoneid_t queried = SCARG(uap, z);
+	*retval = -1;
+
+	/* 
+	 * If the caller specified a zone, should fail if either the
+	 * specified zone doesn't exist or the caller isn't in the global zone
+	 */
+	if (queried != -1 && (zone_exists(queried) == -1 || pr->ps_zid != 0))
+		return (ESRCH);
+	/* 
+	 * Return callers own zone if queried == -1, otherwise
+	 * return the zone id which they queried
+	 */
+	*retval = (queried == -1 ? pr->ps_zid : queried);
+
+	return (0);
+}
+
+/*
+ * Checks whether a zone with a specified zone identifier exists.
+ *
+ *	zid:   The identifier of the zone that will be checked for existence.
+ *
+ *  returns:   -1 If no zone exists with the specified zone id, otherwise,
+ *	       the id of the zone that is queried is returned.
+ */
+int
+zone_exists(zoneid_t zid)
+{
+	struct zone *z;
+	int result = -1;
+
+	/* Global zone always exists */
+	if (zid == 0)
+		return (0);
+	/* Search through queue of zones and check if its zid matches */
+	rw_enter_read(&zone_queue_lock);
+	TAILQ_FOREACH(z, &zones, entry)
+		if (z->zid == zid) {
+			result = zid;
+			break;
+		}
+	rw_exit_read(&zone_queue_lock);
+
+	return (result);
+}
+
+/*
+ * Determines whether a specified process has root privelleges and is
+ * in the global zone (zone 0.)
+ *
+ *     proc:   The process to be checked
+ *
+ *  returns:   1 if the specified process has root privelleges and is
+ *	       in the global zone. 0 otherwise.
+ */
+int
+is_authorised(struct proc *p)
+{
+	return (p->p_ucred->cr_ruid == 0 && p->p_p->ps_zid == 0);
+}
+
+/*
+ * Determines whether a zone (by zone id) is occupied (i.e. 
+ * whether there are any processes in the zone.)
+ *
+ * This function makes no check that a zone with the specified 
+ * identifier exists.
+ *
+ *      zid:   The identifier of the zone to be checked
+ *
+ *  returns:   1 if the zone is in use, 0 otherwise.
+ */
+int
+zone_in_use(zoneid_t zid)
+{
+	struct process *pr;
+
+	/* Search through all process to see if the zone is in use */
+	LIST_FOREACH(pr, &allprocess, ps_list)
+		if (pr->ps_zid == zid)
+			return (1);
+
+	return (0);
+}
+
+/*
+ * Determines the time that a zone was created on the system.
+ *
+ *      zid:   The identifier of the zone to get the creation time for
+ *
+ *  returns:   A pointer to a timeval struct that represents the
+ *	       time at which the specified zone was created, or
+ *	       NULL if that zone currently does not exist.
+ */
+struct timeval *
+zones_get_creation_time(zoneid_t zid)
+{
+	struct zone *z;
+	struct timeval *result = NULL;
+	
+	rw_enter_read(&zone_queue_lock);
+	TAILQ_FOREACH(z, &zones, entry)
+		if (z->zid == zid) {
+			result = z->creation_time;
+			break;
+		}
+	rw_exit_read(&zone_queue_lock);
+
+	return result;
+}
+
+/*
+ * Populates a specified zone structure with the relevant zone id and
+ * creation time.
+ *
+ * The zone struct pointed to by the zone argument should be allocated
+ * before using this function.
+ *
+ *     zone:   A pointer to the zone structure that should be populated.
+ *      zid:   The identifier of the zone to get the creation time for
+ */
+void
+populate_zone_fields(struct zone *zone, zoneid_t zid)
+{
+	struct timespec bt, ut, res;
+	zone->zid = zid;
+
+	zone->creation_time = malloc(sizeof(bt), M_TEMP, M_WAITOK|M_ZERO);
+	/* UTC time at which system booted */
+	nanoboottime(&bt);
+	/* Time since boot */
+	nanouptime(&ut);
+	/* Creation time is the sum of the two above */
+	timespecadd(&bt, &ut, &res);
+	/* Convert res to struct timeval* and place into creation_time field */
+	TIMESPEC_TO_TIMEVAL(zone->creation_time, &res);
+}
+
+/*
+ * Deallocates memory associated with storing a zone structure.
+ *
+ *	z:   A pointer to the zone structure that should be free'd
+ */
+void
+free_zone(struct zone *z)
+{
+	free(z->creation_time, M_TEMP, 0);
+	free(z, M_TEMP, 0);
+}
\ No newline at end of file
Index: sys/kern/syscalls.c
===================================================================
RCS file: /cvs/src/sys/kern/syscalls.c,v
retrieving revision 1.217
diff -u -p -u -p -r1.217 syscalls.c
--- sys/kern/syscalls.c	18 Mar 2020 19:35:00 -0000	1.217
+++ sys/kern/syscalls.c	25 Oct 2020 15:47:18 -0000
@@ -1,4 +1,4 @@
-/*	$OpenBSD: syscalls.c,v 1.217 2020/03/18 19:35:00 anton Exp $	*/
+/*	$OpenBSD$	*/
 
 /*
  * System call names.
@@ -234,11 +234,11 @@ char *syscallnames[] = {
 	"getpgid",			/* 207 = getpgid */
 	"#208 (obsolete nnpfspioctl)",		/* 208 = obsolete nnpfspioctl */
 	"utrace",			/* 209 = utrace */
-	"#210 (unimplemented)",		/* 210 = unimplemented */
-	"#211 (unimplemented)",		/* 211 = unimplemented */
-	"#212 (unimplemented)",		/* 212 = unimplemented */
-	"#213 (unimplemented)",		/* 213 = unimplemented */
-	"#214 (unimplemented)",		/* 214 = unimplemented */
+	"zone_create",			/* 210 = zone_create */
+	"zone_destroy",			/* 211 = zone_destroy */
+	"zone_enter",			/* 212 = zone_enter */
+	"zone_list",			/* 213 = zone_list */
+	"zone_lookup",			/* 214 = zone_lookup */
 	"#215 (unimplemented)",		/* 215 = unimplemented */
 	"#216 (unimplemented)",		/* 216 = unimplemented */
 	"#217 (unimplemented)",		/* 217 = unimplemented */
Index: sys/kern/syscalls.master
===================================================================
RCS file: /cvs/src/sys/kern/syscalls.master,v
retrieving revision 1.207
diff -u -p -u -p -r1.207 syscalls.master
--- sys/kern/syscalls.master	18 Mar 2020 19:33:36 -0000	1.207
+++ sys/kern/syscalls.master	25 Oct 2020 15:47:18 -0000
@@ -368,11 +368,11 @@
 ;
 ; Syscalls 210-219 were reserved for dynamically loaded syscalls
 ;
-210	UNIMPL
-211	UNIMPL
-212	UNIMPL
-213	UNIMPL
-214	UNIMPL
+210	STD		{ int sys_zone_create(zoneid_t z); }
+211	STD		{ int sys_zone_destroy(zoneid_t z); }
+212	STD		{ int sys_zone_enter(zoneid_t z); }
+213	STD		{ int sys_zone_list(zoneid_t *zs, size_t *nzs); }
+214	STD		{ int sys_zone_lookup(zoneid_t z); }
 215	UNIMPL
 216	UNIMPL
 217	UNIMPL
Index: sys/sys/_types.h
===================================================================
RCS file: /cvs/src/sys/sys/_types.h,v
retrieving revision 1.9
diff -u -p -u -p -r1.9 _types.h
--- sys/sys/_types.h	22 Aug 2014 23:05:15 -0000	1.9
+++ sys/sys/_types.h	25 Oct 2020 15:47:18 -0000
@@ -64,6 +64,7 @@ typedef	__int32_t	__swblk_t;	/* swap off
 typedef	__int64_t	__time_t;	/* epoch time */
 typedef	__int32_t	__timer_t;	/* POSIX timer identifiers */
 typedef	__uint32_t	__uid_t;	/* user id */
+typedef	__int32_t	__zoneid_t;	/* zone id */
 typedef	__uint32_t	__useconds_t;	/* microseconds */
 
 /*
Index: sys/sys/_zones.h
===================================================================
RCS file: sys/sys/_zones.h
diff -N sys/sys/_zones.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sys/sys/_zones.h	25 Oct 2020 15:47:18 -0000
@@ -0,0 +1,8 @@
+#ifndef _SYS__ZONES_H_
+#define _SYS__ZONES_H_
+
+#include <sys/param.h>
+
+struct timeval *zones_get_creation_time(zoneid_t);
+
+#endif /* _SYS__ZONES_H */
\ No newline at end of file
Index: sys/sys/proc.h
===================================================================
RCS file: /cvs/src/sys/sys/proc.h,v
retrieving revision 1.300
diff -u -p -u -p -r1.300 proc.h
--- sys/sys/proc.h	16 Sep 2020 08:01:15 -0000	1.300
+++ sys/sys/proc.h	25 Oct 2020 15:47:18 -0000
@@ -190,6 +190,7 @@ struct process {
 	struct	filedesc *ps_fd;	/* Ptr to open files structure */
 	struct	vmspace *ps_vmspace;	/* Address space */
 	pid_t	ps_pid;			/* Process identifier. */
+	int32_t ps_zid;			/* Zone identifier. */
 
 	struct	futex_list ps_ftlist;	/* futexes attached to this process */
 	struct	tslpqueue ps_tslpqueue;	/* [p] queue of threads in thrsleep */
Index: sys/sys/syscall.h
===================================================================
RCS file: /cvs/src/sys/sys/syscall.h,v
retrieving revision 1.215
diff -u -p -u -p -r1.215 syscall.h
--- sys/sys/syscall.h	18 Mar 2020 19:35:00 -0000	1.215
+++ sys/sys/syscall.h	25 Oct 2020 15:47:18 -0000
@@ -1,4 +1,4 @@
-/*	$OpenBSD: syscall.h,v 1.215 2020/03/18 19:35:00 anton Exp $	*/
+/*	$OpenBSD$	*/
 
 /*
  * System call numbers.
@@ -513,6 +513,21 @@
 				/* 208 is obsolete nnpfspioctl */
 /* syscall: "utrace" ret: "int" args: "const char *" "const void *" "size_t" */
 #define	SYS_utrace	209
+
+/* syscall: "zone_create" ret: "int" args: "zoneid_t" */
+#define	SYS_zone_create	210
+
+/* syscall: "zone_destroy" ret: "int" args: "zoneid_t" */
+#define	SYS_zone_destroy	211
+
+/* syscall: "zone_enter" ret: "int" args: "zoneid_t" */
+#define	SYS_zone_enter	212
+
+/* syscall: "zone_list" ret: "int" args: "zoneid_t *" "size_t *" */
+#define	SYS_zone_list	213
+
+/* syscall: "zone_lookup" ret: "int" args: "zoneid_t" */
+#define	SYS_zone_lookup	214
 
 /* syscall: "semget" ret: "int" args: "key_t" "int" "int" */
 #define	SYS_semget	221
Index: sys/sys/syscallargs.h
===================================================================
RCS file: /cvs/src/sys/sys/syscallargs.h,v
retrieving revision 1.218
diff -u -p -u -p -r1.218 syscallargs.h
--- sys/sys/syscallargs.h	18 Mar 2020 19:35:00 -0000	1.218
+++ sys/sys/syscallargs.h	25 Oct 2020 15:47:18 -0000
@@ -1,4 +1,4 @@
-/*	$OpenBSD: syscallargs.h,v 1.218 2020/03/18 19:35:00 anton Exp $	*/
+/*	$OpenBSD$	*/
 
 /*
  * System call argument lists.
@@ -822,6 +822,27 @@ struct sys_utrace_args {
 	syscallarg(size_t) len;
 };
 
+struct sys_zone_create_args {
+	syscallarg(zoneid_t) z;
+};
+
+struct sys_zone_destroy_args {
+	syscallarg(zoneid_t) z;
+};
+
+struct sys_zone_enter_args {
+	syscallarg(zoneid_t) z;
+};
+
+struct sys_zone_list_args {
+	syscallarg(zoneid_t *) zs;
+	syscallarg(size_t *) nzs;
+};
+
+struct sys_zone_lookup_args {
+	syscallarg(zoneid_t) z;
+};
+
 struct sys_semget_args {
 	syscallarg(key_t) key;
 	syscallarg(int) nsems;
@@ -1281,6 +1302,11 @@ int	sys_mlock(struct proc *, void *, reg
 int	sys_munlock(struct proc *, void *, register_t *);
 int	sys_getpgid(struct proc *, void *, register_t *);
 int	sys_utrace(struct proc *, void *, register_t *);
+int	sys_zone_create(struct proc *, void *, register_t *);
+int	sys_zone_destroy(struct proc *, void *, register_t *);
+int	sys_zone_enter(struct proc *, void *, register_t *);
+int	sys_zone_list(struct proc *, void *, register_t *);
+int	sys_zone_lookup(struct proc *, void *, register_t *);
 #ifdef SYSVSEM
 int	sys_semget(struct proc *, void *, register_t *);
 #else
Index: sys/sys/sysctl.h
===================================================================
RCS file: /cvs/src/sys/sys/sysctl.h,v
retrieving revision 1.211
diff -u -p -u -p -r1.211 sysctl.h
--- sys/sys/sysctl.h	1 Sep 2020 01:53:50 -0000	1.211
+++ sys/sys/sysctl.h	25 Oct 2020 15:47:18 -0000
@@ -38,6 +38,9 @@
 #ifndef _SYS_SYSCTL_H_
 #define	_SYS_SYSCTL_H_
 
+#include <sys/param.h>
+#include <sys/tree.h>
+
 #include <uvm/uvmexp.h>
 
 /*
@@ -284,6 +287,31 @@ struct ctlname {
 }
 
 /*
+ * Used for CTL_KERN variables that exist on a per-zone basis.
+ * For example, suppose there exists a zone with zone id 1, and
+ * a zone with zone id 2. Sysctl should allow both zones to have
+ * some variables unique (e.g. hostname of zone 1 != hostname of
+ * zone 2.)
+ */
+struct zone_variables {
+	char	hostname[MAXHOSTNAMELEN];	/* Host name */
+	char	domainname[MAXHOSTNAMELEN];	/* Domain name */
+	long	hostid;				/* Hostid */
+	int	hostnamelen;			/* Host name length */
+	int	domainnamelen;			/* Domain name length */
+};
+
+/*
+ * Used by kern_sysctl.c for recording zone_variables structures
+ * (as above) in a splay tree.
+ */
+struct zone_node {
+	SPLAY_ENTRY(zone_node) entry;		/* Tree entry */
+	zoneid_t 	zid;			/* Zone id of tree node */
+	struct 		zone_variables *vars;	/* Ptr to instance of above */
+};
+
+/*
  * KERN_PROC subtypes
  */
 #define	KERN_PROC_ALL		0	/* everything but kernel threads */
@@ -472,6 +500,7 @@ struct kinfo_proc {
 	u_int32_t p_rtableid;		/* U_INT: Routing table identifier. */
 
 	u_int64_t p_pledge;		/* U_INT64_T: Pledge flags. */
+	int32_t   p_zoneid;		/* ZONEID_T: zone identifier */
 };
 
 /*
@@ -1013,7 +1042,7 @@ int sysctl_rdstring(void *, size_t *, vo
 int sysctl_rdstruct(void *, size_t *, void *, const void *, size_t);
 int sysctl_struct(void *, size_t *, void *, size_t, void *, size_t);
 int sysctl_file(int *, u_int, char *, size_t *, struct proc *);
-int sysctl_doproc(int *, u_int, char *, size_t *);
+int sysctl_doproc(struct proc *, int *, u_int, char *, size_t *);
 struct mbuf_queue;
 int sysctl_mq(int *, u_int, void *, size_t *, void *, size_t,
     struct mbuf_queue *);
@@ -1060,6 +1089,9 @@ int pflow_sysctl(int *, u_int, void *, s
 int pipex_sysctl(int *, u_int, void *, size_t *, void *, size_t);
 int mpls_sysctl(int *, u_int, void *, size_t *, void *, size_t);
 int pf_sysctl(void *, size_t *, void *, size_t);
+
+/* Zoning */
+void	sysctl_destroy_zone(zoneid_t);
 
 #else	/* !_KERNEL */
 
Index: sys/sys/types.h
===================================================================
RCS file: /cvs/src/sys/sys/types.h,v
retrieving revision 1.48
diff -u -p -u -p -r1.48 types.h
--- sys/sys/types.h	9 Feb 2019 04:54:11 -0000	1.48
+++ sys/sys/types.h	25 Oct 2020 15:47:18 -0000
@@ -146,6 +146,7 @@ typedef	__rlim_t	rlim_t;		/* resource li
 typedef	__segsz_t	segsz_t;	/* segment size */
 typedef	__swblk_t	swblk_t;	/* swap offset */
 typedef	__uid_t		uid_t;		/* user id */
+typedef	__zoneid_t	zoneid_t;	/* zone id */
 typedef	__useconds_t	useconds_t;	/* microseconds */
 typedef	__suseconds_t	suseconds_t;	/* microseconds (signed) */
 typedef	__fsblkcnt_t	fsblkcnt_t;	/* file system block count */
Index: sys/sys/zones.h
===================================================================
RCS file: sys/sys/zones.h
diff -N sys/sys/zones.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sys/sys/zones.h	25 Oct 2020 15:47:18 -0000
@@ -0,0 +1,28 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2019 The University of Queensland
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _SYS_ZONES_H_
+#define _SYS_ZONES_H_
+
+#define MAXZONES	1024
+#define MAXZONEIDS	(MAXZONES * 32)
+
+/* your assignment code goes in src/sys/sys/_zones.h */
+#include <sys/_zones.h>
+
+#endif /* _SYS_ZONES_H_ */
Index: usr.bin/pkill/pkill.c
===================================================================
RCS file: /cvs/src/usr.bin/pkill/pkill.c,v
retrieving revision 1.42
diff -u -p -u -p -r1.42 pkill.c
--- usr.bin/pkill/pkill.c	16 Dec 2019 19:21:17 -0000	1.42
+++ usr.bin/pkill/pkill.c	25 Oct 2020 15:47:20 -0000
@@ -52,6 +52,7 @@
 #include <pwd.h>
 #include <grp.h>
 #include <errno.h>
+#include <zones.h>
 
 #define	STATUS_MATCH	0
 #define	STATUS_NOMATCH	1
@@ -107,6 +108,7 @@ static int	grepact(struct kinfo_proc *, 
 static void	makelist(struct listhead *, enum listtype, char *);
 static char	*getargv(struct kinfo_proc *);
 static int	askyn(struct kinfo_proc *);
+static zoneid_t	getzoneid(const char *);
 
 extern char *__progname;
 
@@ -148,6 +150,8 @@ main(int argc, char **argv)
 	u_int32_t bestsec, bestusec;
 	regex_t reg;
 	regmatch_t regmatch;
+	const char *zone = NULL;
+	zoneid_t z = -1;
 
 	if (strcmp(__progname, "pgrep") == 0) {
 		action = grepact;
@@ -180,7 +184,7 @@ main(int argc, char **argv)
 
 	criteria = 0;
 
-	while ((ch = getopt(argc, argv, "G:P:T:U:d:fg:Ilnoqs:t:u:vx")) != -1)
+	while ((ch = getopt(argc, argv, "G:P:T:U:d:fg:Ilnoqs:t:u:vxz:")) != -1)
 		switch (ch) {
 		case 'G':
 			makelist(&rgidlist, LT_GROUP, optarg);
@@ -245,6 +249,9 @@ main(int argc, char **argv)
 		case 'x':
 			fullmatch = 1;
 			break;
+		case 'z':
+			zone = optarg;
+			break;
 		default:
 			usage();
 			/* NOTREACHED */
@@ -259,6 +266,9 @@ main(int argc, char **argv)
 
 	mypid = getpid();
 
+	if (zone != NULL)
+		z = getzoneid(zone);
+
 	/*
 	 * Retrieve the list of running processes from the kernel.
 	 */
@@ -297,7 +307,8 @@ main(int argc, char **argv)
 		}
 
 		for (i = 0, kp = plist; i < nproc; i++, kp++) {
-			if (kp->p_pid == mypid)
+			if (kp->p_pid == mypid ||
+			    (z != -1 && z != kp->p_zoneid))
 				continue;
 
 			if (matchargs)
@@ -323,7 +334,8 @@ main(int argc, char **argv)
 	}
 
 	for (i = 0, kp = plist; i < nproc; i++, kp++) {
-		if (kp->p_pid == mypid)
+		if (kp->p_pid == mypid ||
+		    (z != -1 && z != kp->p_zoneid))
 			continue;
 
 		SLIST_FOREACH(li, &ruidlist, li_chain)
@@ -433,7 +445,8 @@ main(int argc, char **argv)
 	 */
 	rv = STATUS_NOMATCH;
 	for (i = 0, j = 0, kp = plist; i < nproc; i++, kp++) {
-		if (kp->p_pid == mypid)
+		if (kp->p_pid == mypid ||
+		    (z != -1 && z != kp->p_zoneid))
 			continue;
 		if (selected[i] == inverse)
 			continue;
@@ -468,7 +481,8 @@ usage(void)
 		ustr = "[-signal] [-fIlnoqvx]";
 
 	fprintf(stderr, "usage: %s %s [-G gid] [-g pgrp] [-P ppid] [-s sid]"
-	    "\n\t[-T rtable] [-t tty] [-U uid] [-u euid] [pattern ...]\n",
+	    "\n\t[-T rtable] [-t tty] [-U uid] [-u euid] [-z zone]"
+	    " [pattern ...]\n",
 	    __progname, ustr);
 
 	exit(STATUS_BADUSAGE);
@@ -629,4 +643,17 @@ makelist(struct listhead *head, enum lis
 
 	if (empty)
 		usage();
+}
+
+static zoneid_t
+getzoneid(const char *zone)
+{
+	const char *errstr;
+	zoneid_t z;
+
+	z = strtonum(zone, 0, MAXZONEIDS, &errstr);
+	if (errstr != NULL)
+		errx(1, "zone id %s: %s", zone, errstr);
+
+	return (z);
 }
Index: usr.sbin/Makefile
===================================================================
RCS file: /cvs/src/usr.sbin/Makefile,v
retrieving revision 1.211
diff -u -p -u -p -r1.211 Makefile
--- usr.sbin/Makefile	12 Sep 2020 17:55:10 -0000	1.211
+++ usr.sbin/Makefile	25 Oct 2020 15:47:21 -0000
@@ -19,7 +19,7 @@ SUBDIR=	ac accton acme-client acpidump a
 	snmpd spamdb switchctl switchd syslogc syslogd sysmerge \
 	syspatch sysupgrade tcpdrop tcpdump tftp-proxy tftpd tokenadm \
 	tokeninit traceroute trpt unbound unwindctl usbdevs user vmd vmctl \
-	vipw watchdogd wsconscfg wsfontload wsmoused zdump zic
+	vipw watchdogd wsconscfg wsfontload wsmoused zdump zic zone
 
 .if (${YP:L} == "yes")
 SUBDIR+=ypbind ypldap yppoll ypset ypserv
Index: usr.sbin/zone/Makefile
===================================================================
RCS file: usr.sbin/zone/Makefile
diff -N usr.sbin/zone/Makefile
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ usr.sbin/zone/Makefile	25 Oct 2020 15:47:24 -0000
@@ -0,0 +1,6 @@
+PROG=zone
+SRCS=zone.c
+MAN=
+CFLAGS+=-Wall
+
+.include <bsd.prog.mk>
Index: usr.sbin/zone/zone.c
===================================================================
RCS file: usr.sbin/zone/zone.c
diff -N usr.sbin/zone/zone.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ usr.sbin/zone/zone.c	25 Oct 2020 15:47:24 -0000
@@ -0,0 +1,234 @@
+/*	$OpenBSD$ */
+
+/*
+ * Copyright (c) 2015, 2019, 2020 The University of Queensland
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <sys/types.h>
+#include <sys/wait.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <signal.h>
+#include <unistd.h>
+#include <err.h>
+#include <errno.h>
+#include <zones.h>
+
+#ifndef nitems
+#define nitems(_a) (sizeof(_a) / sizeof(_a[0]))
+#endif
+
+static int	zcreate(int, char *[]);
+static int	zdestroy(int, char *[]);
+static int	zexec(int, char *[]);
+static int	zlist(int, char *[]);
+static int	zlookup(int, char *[]);
+
+__dead void usage(void);
+
+struct task {
+	const char *name;
+	int (*task)(int, char *[]);
+};
+
+/* must be sorted alphanumerically */
+static const struct task tasks[] = {
+	{ "create",	zcreate },
+	{ "destroy",	zdestroy },
+	{ "exec",	zexec },
+	{ "list",	zlist },
+	{ "lookup",	zlookup },
+};
+
+static int	task_cmp(const void *, const void *);
+
+static int
+task_cmp(const void *a, const void *b)
+{
+	const struct task *ta = a;
+	const struct task *tb = b;
+	
+	return (strcmp(ta->name, tb->name));
+}
+
+__dead void
+usage(void)
+{
+	extern char *__progname;
+
+	fprintf(stderr, "usage:\t%s create zoneid\n", __progname);
+	fprintf(stderr, "\t%s destroy zoneid\n", __progname);
+	fprintf(stderr, "\t%s list\n", __progname);
+	fprintf(stderr, "\t%s lookup [zoneid]\n", __progname);
+	fprintf(stderr, "\t%s exec zoneid command ...\n", __progname);
+
+	exit(1);
+}
+
+int
+main(int argc, char *argv[])
+{
+	struct task key, *t;
+
+	if (argc < 2)
+		usage();
+
+	key.name = argv[1];
+	t = bsearch(&key, tasks, nitems(tasks), sizeof(tasks[0]), task_cmp);
+	if (t == NULL)
+		usage();
+
+	argc -= 2;
+	argv += 2;
+
+	return (t->task(argc, argv));
+}
+
+static zoneid_t
+getzoneid(const char *zone)
+{
+	const char *errstr;
+	zoneid_t z;
+
+	z = strtonum(zone, 0, MAXZONEIDS, &errstr);
+	if (errstr != NULL)
+		errx(1, "zone id %s: %s", zone, errstr);
+
+	return (z);
+}
+
+static int
+zcreate(int argc, char *argv[])
+{
+	const char *zone;
+	zoneid_t z;
+
+	if (argc != 1)
+		usage();
+
+	zone = argv[0];
+
+	z = getzoneid(zone);
+	if (zone_create(z) == -1)
+		err(1, "create %s", zone);
+
+	return (0);
+}
+
+static int
+zdestroy(int argc, char *argv[])
+{
+	const char *zone;
+	zoneid_t z;
+
+	if (argc != 1)
+		usage();
+
+	zone = argv[0];
+
+	z = getzoneid(zone);
+	if (zone_destroy(z) == -1)
+		err(1, "destroy %s", zone);
+
+	return (0);
+}
+
+static int
+zexec(int argc, char *argv[])
+{
+	const char *zone;
+	zoneid_t z;
+
+	if (argc < 2)
+		usage();
+
+	zone = argv[0];
+	z = getzoneid(zone);
+
+	argc -= 1;
+	argv += 1;
+
+	if (zone_enter(z) == -1)
+		err(1, "enter %s", zone);
+
+	execvp(argv[0], argv);
+
+	err(1, "exec %s", argv[0]);
+	/* NOTREACHED */
+}
+
+static int
+zlist(int argc, char *argv[])
+{
+	zoneid_t *zs = NULL;
+	size_t nzs, i = 8;
+	zoneid_t z;
+
+	if (argc != 0)
+		usage();
+
+	for (;;) {
+		nzs = i;
+
+		zs = reallocarray(zs, nzs, sizeof(*zs));
+		if (zs == NULL)
+			err(1, "lookup");
+
+		if (zone_list(zs, &nzs) == 0)
+			break;
+
+		if (errno != EFAULT)
+			err(1, "list");
+
+		i <<= 1;
+	}
+
+	printf("%8s %s\n", "ID", "NAME");
+
+	for (i = 0; i < nzs; i++) {
+		z = zs[i];
+		printf("%8d\n", z);
+	}
+
+	free(zs);
+
+	return (0);
+}
+
+static int
+zlookup(int argc, char *argv[])
+{
+	zoneid_t z = -1;
+
+	switch (argc) {
+	case 1:
+		z = getzoneid(argv[0]);
+		break;
+	case 0:
+		break;
+	default:
+		usage();
+	}
+
+	z = zone_lookup(z);
+	if (z == -1)
+		err(1, "lookup %d", z);
+
+	printf("%d\n", z);
+
+	return (0);
+}
